1.rabbitmq核心组件:
    producer : 生产者
    exchange : 交换机
    queue : 队列
    consumer : 消费者

2.rabbitmq的执行流程:
    生产者生产消息 --发送--> 交换机 --根据routingKey--> 队列 ----> 消费者消费

3.生产者细节:
    生产者发送消息给交换机,为了保证消息是否到达mq,可以开启发布确认模式,此时交换机接收到消息会发送一条确认信息给生产者;
    有时候交换机接收到消息,但是找不到指定的路由键的队列,此时会丢失该消息,我们可以使用消息退回或者为交换机绑定备用交换机来进行处理;

4.交换机细节:
     交换机是接收消费者消息,并且把消费根据路由键分发到指定的队列中;路由可以绑定一个或者多个队列;
     路由类型:
            direct : 一对一的关系,一个路由键对应一个队列
            fanout : 一对多的关系,路由键没有意义,因为此类型的交换机会把消息发送给每一个绑定的队列,所有路由键可以设置为空字符串
            topic : 类型redis里面的psubscribe和publish,绑定的路由键可以包含通配符,生产者发送的消息会根据统配比对,达到指定队列
            x-delayed-message : 额外插件的延迟队列,延迟多少时间后才能被消费

5.队列细节:
    每个队列必须绑定一个交换机,队列不能直接接收生产者的消息,只能接收交换机发送过来的消息;
    队列的类型:
            普通队列 : 队列里的消息不被消费会一直存在;
            ttl队列 : 队列设置消息的过期时间,如果在指定的时间内消息没有被消费,那么队列会丢失该消息或者加入到死信队列;
            延迟队列 : 队列里面消息在延迟指定的时间后才能被消费,使用额外的插件实现;
            优先级队列 : 为队列和队列里面的消息设置优先级,优先级高的队列和消息可以优先被消费;
            惰性队列 : 队列把数据都存在硬盘中,等需要的时候才会从硬盘中取,节省了内存空间;
            死信队列 : 创建一个死信队列跟其它队列进行绑定;消息在过期时间内没被消费,超出队列容量的消息,消息被消费者拒绝消费都会进入死信队列;

6.消费者细节:
    消费者从队列中获取消息进行消费;默认是只要队列把消息发送给消费者立马会被标记为已签收,为了保证消息一定被消费,我们可以开启手动签收,只有当消息者,消费完
    才会发送ack给mq,这时才会将该条消息设置为签收,并且删除,否则会重新发送给其它消费者进行消费.



